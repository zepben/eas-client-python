#  Copyright 2020 Zeppelin Bend Pty Ltd
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at https://mozilla.org/MPL/2.0/.
import ssl
import warnings
from asyncio import get_event_loop
from hashlib import sha256
from http import HTTPStatus
from json import dumps
from typing import Optional, List

import aiohttp
from aiohttp import ClientSession
from urllib3.exceptions import InsecureRequestWarning
from zepben.auth import AuthMethod, ZepbenTokenFetcher, create_token_fetcher, create_token_fetcher_managed_identity

from zepben.eas.client.feeder_load_analysis_input import FeederLoadAnalysisInput
from zepben.eas.client.opendss import OpenDssConfig, GetOpenDssModelsFilterInput, GetOpenDssModelsSortCriteriaInput
from zepben.eas.client.study import Study
from zepben.eas.client.util import construct_url
from zepben.eas.client.work_package import WorkPackageConfig, FixedTime, TimePeriod, ForecastConfig, FeederConfigs

__all__ = ["EasClient"]


class EasClient:
    """
    A class used to represent a client to the Evolve App Server, with methods that represent requests to its API.
    """

    def __init__(
        self,
        host: str,
        port: int,
        protocol: str = "https",
        client_id: Optional[str] = None,
        username: Optional[str] = None,
        password: Optional[str] = None,
        access_token: Optional[str] = None,
        client_secret: Optional[str] = None,
        token_fetcher: Optional[ZepbenTokenFetcher] = None,
        verify_certificate: bool = True,
        ca_filename: Optional[str] = None,
        session: ClientSession = None,
        json_serialiser=None
    ):
        """
        Construct a client for the Evolve App Server. If the server is HTTPS, authentication may be configured.
        Authentication may be configured in one of three ways:
            - Providing an access token via the access_token parameter
            - Specifying the client ID of the Auth0 application via the client_id parameter, plus one of the following:
                - A username and password pair via the username and password parameters (account authentication)
                - The client secret via the client_secret parameter (M2M authentication)
              If this method is used, the auth configuration will be fetched from the Evolve App Server at the path
              "/api/config/auth".
            - Specifying a ZepbenTokenFetcher directly via the token_fetcher parameter

        Address parameters:
        :param host: The domain of the Evolve App Server, e.g. "evolve.local"
        :param port: The port on which to make requests to the Evolve App Server, e.g. 7624
        :param protocol: The protocol of the Evolve App Server. Should be either "http" or "https". Must be "https" if
                         auth is configured. (Defaults to "https")

        Authentication parameters:
        :param client_id: The Auth0 client ID used to specify to the auth server which application to request a token
                          for. (Optional)
        :param username: The username used for account authentication. (Optional)
        :param password: The password used for account authentication. (Optional)
        :param access_token: The access token used for authentication, generated by Evolve App Server. (Optional)
        :param client_secret: The Auth0 client secret used for M2M authentication. (Optional)
        :param token_fetcher: A ZepbenTokenFetcher used to fetch auth tokens for access to the Evolve App Server.
                              (Optional)

        HTTP/HTTPS parameters:
        :param verify_certificate: Set this to "False" to disable certificate verification. This will also apply to the
                                   auth provider if auth is initialised via client id + username + password or
                                   client_id + client_secret. (Defaults to True)
        :param ca_filename: Path to CA file to use for verification. (Optional)
        :param session: aiohttp ClientSession to use, if not provided a new session will be created for you. You should
                        typically only use one aiohttp session per application.
        :param json_serialiser: JSON serialiser to use for requests e.g. ujson.dumps. (Defaults to json.dumps)
        """
        self._protocol = protocol
        self._host = host
        self._port = port
        self._verify_certificate = verify_certificate
        self._ca_filename = ca_filename
        self._access_token = access_token
        if protocol != "https" and (token_fetcher or client_id or access_token):
            raise ValueError(
                "Incompatible arguments passed to connect to secured Evolve App Server. "
                "Authentication tokens must be sent via https. "
                "To resolve this issue, exclude the \"protocol\" argument when initialising the EasClient.")

        if access_token and (client_id or client_secret or username or password or token_fetcher):
            raise ValueError(
                "Incompatible arguments passed to connect to secured Evolve App Server. "
                "You cannot provide multiple types of authentication. "
                "When using an access_token, do not provide client_id, client_secret, username, password, or token_fetcher."
            )

        if token_fetcher and (client_id or client_secret or username or password or access_token):
            raise ValueError(
                "Incompatible arguments passed to connect to secured Evolve App Server. "
                "You cannot provide both a token_fetcher and credentials, "
                "please provide either client_id, client_id + client_secret, username + password, access_token or token_fetcher."
            )

        if client_id:
            self._token_fetcher = create_token_fetcher(
                conf_address=f"{self._protocol}://{self._host}:{self._port}/api/config/auth",
                verify_conf=self._verify_certificate,
            )
            if self._token_fetcher:
                self._token_fetcher.token_request_data.update({
                    'client_id': client_id,
                    'scope':
                        'trusted' if self._token_fetcher.auth_method is AuthMethod.SELF
                        else 'offline_access openid profile email0'
                })
                self._token_fetcher.refresh_request_data.update({
                    "grant_type": "refresh_token",
                    'client_id': client_id,
                    'scope':
                        'trusted' if self._token_fetcher.auth_method is AuthMethod.SELF
                        else 'offline_access openid profile email0'
                })
                if username and password:
                    self._token_fetcher.token_request_data.update({
                        'grant_type': 'password',
                        'username': username,
                        'password':
                            sha256(password.encode('utf-8')).hexdigest()
                            if self._token_fetcher.auth_method is AuthMethod.SELF
                            else password
                    })
                    if client_secret:
                        self._token_fetcher.token_request_data.update({'client_secret': client_secret})
                elif client_secret:
                    self._token_fetcher.token_request_data.update({
                        'grant_type': 'client_credentials',
                        'client_secret': client_secret
                    })
                else:
                    # Attempt azure managed identity (what a hack)
                    url = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01"
                    self._token_fetcher = create_token_fetcher_managed_identity(
                        identity_url=f"{url}&resource={client_id}",
                        verify_auth=self._verify_certificate
                    )
        elif token_fetcher:
            self._token_fetcher = token_fetcher
        else:
            self._token_fetcher = None

        if session is None:
            conn = aiohttp.TCPConnector(limit=200, limit_per_host=0)
            timeout = aiohttp.ClientTimeout(total=60)
            self.session = aiohttp.ClientSession(json_serialize=json_serialiser or dumps, connector=conn,
                                                 timeout=timeout)
        else:
            self.session = session

    def close(self):
        return get_event_loop().run_until_complete(self.aclose())

    async def aclose(self):
        await self.session.close()

    def _get_request_headers(self, content_type: str = "application/json") -> dict:
        headers = {"content-type": content_type}
        if self._access_token:
            headers["authorization"] = f"Bearer {self._access_token}"
        elif self._token_fetcher:
            headers["authorization"] = self._token_fetcher.fetch_token()
        return headers

    def run_hosting_capacity_work_package(self, work_package: WorkPackageConfig):
        """
        Send request to hosting capacity service to run work package

        :param work_package: An instance of the `WorkPackageConfig` data class representing the work package configuration for the run
        :return: The HTTP response received from the Evolve App Server after attempting to run work package
        """
        return get_event_loop().run_until_complete(self.async_run_hosting_capacity_work_package(work_package))

    def get_work_package_cost_estimation(self, work_package: WorkPackageConfig):
        """
        Send request to hosting capacity service to get an estimate cost of supplied work package

        :param work_package: An instance of the `WorkPackageConfig` data class representing the work package configuration for the run
        :return: The HTTP response received from the Evolve App Server after attempting to run work package
        """
        return get_event_loop().run_until_complete(self.async_get_work_package_cost_estimation(work_package))

    async def async_get_work_package_cost_estimation(self, work_package: WorkPackageConfig):
        """
        Send asynchronous request to hosting capacity service to get an estimate cost of supplied work package

        :param work_package: An instance of the `WorkPackageConfig` data class representing the work package configuration for the run
        :return: The HTTP response received from the Evolve App Server after attempting to run work package
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    query getWorkPackageCostEstimation($input: WorkPackageInput!) {
                        getWorkPackageCostEstimation(input: $input)
                    }
                """,
                "variables": {
                    "workPackageName": work_package.name,
                    "input": {
                        "feederConfigs": {
                            "configs": [
                                {
                                    "feeder": config.feeder,
                                    "years": config.years,
                                    "scenarios": config.scenarios,
                                    "timePeriod": {
                                        "startTime": config.load_time.start_time.isoformat(),
                                        "endTime": config.load_time.end_time.isoformat(),
                                        "overrides": config.load_time.load_overrides and [
                                            {
                                                "loadId": key,
                                                "loadWattsOverride": value.load_watts,
                                                "genWattsOverride": value.gen_watts,
                                                "loadVarOverride": value.load_var,
                                                "genVarOverride": value.gen_var,
                                            } for key, value in config.load_time.load_overrides.items()
                                        ]
                                    } if isinstance(config.load_time, TimePeriod) else None,
                                    "fixedTime": config.load_time and {
                                        "loadTime": config.load_time.load_time.isoformat(),
                                        "overrides": config.load_time.load_overrides and [
                                            {
                                                "loadId": key,
                                                "loadWattsOverride": value.load_watts,
                                                "genWattsOverride": value.gen_watts,
                                                "loadVarOverride": value.load_var,
                                                "genVarOverride": value.gen_var,
                                            } for key, value in config.load_time.load_overrides.items()
                                        ]
                                    } if isinstance(config.load_time, FixedTime) else None,
                                } for config in work_package.syf_config.configs
                            ]
                        } if isinstance(work_package.syf_config, FeederConfigs) else None,
                        "forecastConfig": {
                            "feeders": work_package.syf_config.feeders,
                            "years": work_package.syf_config.years,
                            "scenarios": work_package.syf_config.scenarios,
                            "timePeriod": {
                                "startTime": work_package.syf_config.load_time.start_time.isoformat(),
                                "endTime": work_package.syf_config.load_time.end_time.isoformat(),
                                "overrides": work_package.syf_config.load_time.load_overrides and {
                                    key: value.__dict__
                                    for key, value in work_package.syf_config.load_time.load_overrides.items()}
                            } if isinstance(work_package.syf_config.load_time, TimePeriod) else None,
                            "fixedTime": work_package.syf_config.load_time and {
                                "loadTime": work_package.syf_config.load_time.load_time.isoformat(),
                                "overrides": work_package.syf_config.load_time.load_overrides and {
                                    key: value.__dict__
                                    for key, value in work_package.syf_config.load_time.load_overrides.items()}
                            } if isinstance(work_package.syf_config.load_time, FixedTime) else None
                        } if isinstance(work_package.syf_config, ForecastConfig) else None,
                        "qualityAssuranceProcessing": work_package.quality_assurance_processing,
                        "generatorConfig": work_package.generator_config and {
                            "model": work_package.generator_config.model and {
                                "vmPu": work_package.generator_config.model.vm_pu,
                                "loadVMinPu": work_package.generator_config.model.load_vmin_pu,
                                "loadVMaxPu": work_package.generator_config.model.load_vmax_pu,
                                "genVMinPu": work_package.generator_config.model.gen_vmin_pu,
                                "genVMaxPu": work_package.generator_config.model.gen_vmax_pu,
                                "loadModel": work_package.generator_config.model.load_model,
                                "collapseSWER": work_package.generator_config.model.collapse_swer,
                                "calibration": work_package.generator_config.model.calibration,
                                "pFactorBaseExports": work_package.generator_config.model.p_factor_base_exports,
                                "pFactorForecastPv": work_package.generator_config.model.p_factor_forecast_pv,
                                "pFactorBaseImports": work_package.generator_config.model.p_factor_base_imports,
                                "fixSinglePhaseLoads": work_package.generator_config.model.fix_single_phase_loads,
                                "maxSinglePhaseLoad": work_package.generator_config.model.max_single_phase_load,
                                "fixOverloadingConsumers": work_package.generator_config.model.fix_overloading_consumers,
                                "maxLoadTxRatio": work_package.generator_config.model.max_load_tx_ratio,
                                "maxGenTxRatio": work_package.generator_config.model.max_gen_tx_ratio,
                                "fixUndersizedServiceLines": work_package.generator_config.model.fix_undersized_service_lines,
                                "maxLoadServiceLineRatio": work_package.generator_config.model.max_load_service_line_ratio,
                                "maxLoadLvLineRatio": work_package.generator_config.model.max_load_lv_line_ratio,
                                "collapseLvNetworks": work_package.generator_config.model.collapse_lv_networks,
                                "feederScenarioAllocationStrategy": work_package.generator_config.model.feeder_scenario_allocation_strategy and work_package.generator_config.model.feeder_scenario_allocation_strategy.name,
                                "closedLoopVRegEnabled": work_package.generator_config.model.closed_loop_v_reg_enabled,
                                "closedLoopVRegReplaceAll": work_package.generator_config.model.closed_loop_v_reg_replace_all,
                                "closedLoopVRegSetPoint": work_package.generator_config.model.closed_loop_v_reg_set_point,
                                "closedLoopVBand": work_package.generator_config.model.closed_loop_v_band,
                                "closedLoopTimeDelay": work_package.generator_config.model.closed_loop_time_delay,
                                "closedLoopVLimit": work_package.generator_config.model.closed_loop_v_limit,
                                "defaultTapChangerTimeDelay": work_package.generator_config.model.default_tap_changer_time_delay,
                                "defaultTapChangerSetPointPu": work_package.generator_config.model.default_tap_changer_set_point_pu,
                                "defaultTapChangerBand": work_package.generator_config.model.default_tap_changer_band,
                                "splitPhaseDefaultLoadLossPercentage": work_package.generator_config.model.split_phase_default_load_loss_percentage,
                                "splitPhaseLVKV": work_package.generator_config.model.split_phase_lv_kv,
                                "swerVoltageToLineVoltage": work_package.generator_config.model.swer_voltage_to_line_voltage,
                                "loadPlacement": work_package.generator_config.model.load_placement and work_package.generator_config.model.load_placement.name,
                                "loadIntervalLengthHours": work_package.generator_config.model.load_interval_length_hours,
                                "meterPlacementConfig": work_package.generator_config.model.meter_placement_config and {
                                    "feederHead": work_package.generator_config.model.meter_placement_config.feeder_head,
                                    "distTransformers": work_package.generator_config.model.meter_placement_config.dist_transformers,
                                    "switchMeterPlacementConfigs": work_package.generator_config.model.meter_placement_config.switch_meter_placement_configs and [
                                        {
                                            "meterSwitchClass": spc.meter_switch_class and spc.meter_switch_class.name,
                                            "namePattern": spc.name_pattern
                                        } for spc in
                                        work_package.generator_config.model.meter_placement_config.switch_meter_placement_configs
                                    ],
                                    "energyConsumerMeterGroup": work_package.generator_config.model.meter_placement_config.energy_consumer_meter_group
                                },
                                "seed": work_package.generator_config.model.seed,
                                "defaultLoadWatts": work_package.generator_config.model.default_load_watts,
                                "defaultGenWatts": work_package.generator_config.model.default_gen_watts,
                                "defaultLoadVar": work_package.generator_config.model.default_load_var,
                                "defaultGenVar": work_package.generator_config.model.default_gen_var,
                                "transformerTapSettings": work_package.generator_config.model.transformer_tap_settings,
                                "ctPrimScalingFactor": work_package.generator_config.model.ct_prim_scaling_factor,
                            },
                            "solve": work_package.generator_config.solve and {
                                "normVMinPu": work_package.generator_config.solve.norm_vmin_pu,
                                "normVMaxPu": work_package.generator_config.solve.norm_vmax_pu,
                                "emergVMinPu": work_package.generator_config.solve.emerg_vmin_pu,
                                "emergVMaxPu": work_package.generator_config.solve.emerg_vmax_pu,
                                "baseFrequency": work_package.generator_config.solve.base_frequency,
                                "voltageBases": work_package.generator_config.solve.voltage_bases,
                                "maxIter": work_package.generator_config.solve.max_iter,
                                "maxControlIter": work_package.generator_config.solve.max_control_iter,
                                "mode": work_package.generator_config.solve.mode and work_package.generator_config.solve.mode.name,
                                "stepSizeMinutes": work_package.generator_config.solve.step_size_minutes
                            },
                            "rawResults": work_package.generator_config.raw_results and {
                                "energyMeterVoltagesRaw": work_package.generator_config.raw_results.energy_meter_voltages_raw,
                                "energyMetersRaw": work_package.generator_config.raw_results.energy_meters_raw,
                                "resultsPerMeter": work_package.generator_config.raw_results.results_per_meter,
                                "overloadsRaw": work_package.generator_config.raw_results.overloads_raw,
                                "voltageExceptionsRaw": work_package.generator_config.raw_results.voltage_exceptions_raw
                            }
                        },
                        "executorConfig": {},
                        "resultProcessorConfig": work_package.result_processor_config and {
                            "storedResults": work_package.result_processor_config.stored_results and {
                                "energyMeterVoltagesRaw": work_package.result_processor_config.stored_results.energy_meter_voltages_raw,
                                "energyMetersRaw": work_package.result_processor_config.stored_results.energy_meters_raw,
                                "overloadsRaw": work_package.result_processor_config.stored_results.overloads_raw,
                                "voltageExceptionsRaw": work_package.result_processor_config.stored_results.voltage_exceptions_raw,
                            },
                            "metrics": work_package.result_processor_config.metrics and {
                                "calculatePerformanceMetrics": work_package.result_processor_config.metrics.calculate_performance_metrics
                            },
                            "writerConfig": work_package.result_processor_config.writer_config and {
                                "writerType": work_package.result_processor_config.writer_config.writer_type and work_package.result_processor_config.writer_config.writer_type.name,
                                "outputWriterConfig": work_package.result_processor_config.writer_config.output_writer_config and {
                                    "enhancedMetricsConfig": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config and {
                                        "populateEnhancedMetrics": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_enhanced_metrics,
                                        "populateEnhancedMetricsProfile": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_enhanced_metrics_profile,
                                        "populateDurationCurves": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_duration_curves,
                                        "populateConstraints": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_constraints,
                                        "populateWeeklyReports": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_weekly_reports,
                                        "calculateNormalForLoadThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_normal_for_load_thermal,
                                        "calculateEmergForLoadThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_emerg_for_load_thermal,
                                        "calculateNormalForGenThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_normal_for_gen_thermal,
                                        "calculateEmergForGenThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_emerg_for_gen_thermal,
                                        "calculateCO2": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_co2
                                    }
                                }
                            }
                        },
                        "intervention": work_package.intervention and {
                            "baseWorkPackageId": work_package.intervention.base_work_package_id,
                            "yearRange": {
                                "maxYear": work_package.intervention.year_range.max_year,
                                "minYear": work_package.intervention.year_range.min_year
                            },
                            "allocationLimitPerYear": work_package.intervention.allocation_limit_per_year,
                            "interventionType": work_package.intervention.intervention_type.name,
                            "candidateGeneration": work_package.intervention.candidate_generation and {
                                "type": work_package.intervention.candidate_generation.type.name,
                                "interventionCriteriaName": work_package.intervention.candidate_generation.intervention_criteria_name,
                                "voltageDeltaAvgThreshold": work_package.intervention.candidate_generation.voltage_delta_avg_threshold,
                                "voltageUnderLimitHoursThreshold": work_package.intervention.candidate_generation.voltage_under_limit_hours_threshold,
                                "voltageOverLimitHoursThreshold": work_package.intervention.candidate_generation.voltage_over_limit_hours_threshold,
                                "tapWeightingFactorLowerThreshold": work_package.intervention.candidate_generation.tap_weighting_factor_lower_threshold,
                                "tapWeightingFactorUpperThreshold": work_package.intervention.candidate_generation.tap_weighting_factor_upper_threshold,
                            },
                            "allocationCriteria": work_package.intervention.allocation_criteria,
                            "specificAllocationInstance": work_package.intervention.specific_allocation_instance,
                            "phaseRebalanceProportions": work_package.intervention.phase_rebalance_proportions and {
                                "a": work_package.intervention.phase_rebalance_proportions.a,
                                "b": work_package.intervention.phase_rebalance_proportions.b,
                                "c": work_package.intervention.phase_rebalance_proportions.c
                            },
                            "dvms": work_package.intervention.dvms and {
                                "lowerLimit": work_package.intervention.dvms.lower_limit,
                                "upperLimit": work_package.intervention.dvms.upper_limit,
                                "lowerPercentile": work_package.intervention.dvms.lower_percentile,
                                "upperPercentile": work_package.intervention.dvms.upper_percentile,
                                "maxIterations": work_package.intervention.dvms.max_iterations,
                                "regulatorConfig": {
                                    "puTarget": work_package.intervention.dvms.regulator_config.pu_target,
                                    "puDeadbandPercent": work_package.intervention.dvms.regulator_config.pu_deadband_percent,
                                    "maxTapChangePerStep": work_package.intervention.dvms.regulator_config.max_tap_change_per_step,
                                    "allowPushToLimit": work_package.intervention.dvms.regulator_config.allow_push_to_limit
                                }
                            }
                        }
                    }
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    async def async_run_hosting_capacity_work_package(self, work_package: WorkPackageConfig):
        """
        Send asynchronous request to hosting capacity service to run work package

        :param work_package: An instance of the `WorkPackageConfig` data class representing the work package configuration for the run
        :return: The HTTP response received from the Evolve App Server after attempting to run work package
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    mutation runWorkPackage($input: WorkPackageInput!, $workPackageName: String!) {
                        runWorkPackage(input: $input, workPackageName: $workPackageName)
                    }
                """,
                "variables": {
                    "workPackageName": work_package.name,
                    "input": {
                        "feederConfigs": {
                            "configs": [
                                {
                                    "feeder": config.feeder,
                                    "years": config.years,
                                    "scenarios": config.scenarios,
                                    "timePeriod": {
                                        "startTime": config.load_time.start_time.isoformat(),
                                        "endTime": config.load_time.end_time.isoformat(),
                                        "overrides": config.load_time.load_overrides and [
                                            {
                                                "loadId": key,
                                                "loadWattsOverride": value.load_watts,
                                                "genWattsOverride": value.gen_watts,
                                                "loadVarOverride": value.load_var,
                                                "genVarOverride": value.gen_var,
                                            } for key, value in config.load_time.load_overrides.items()
                                        ]
                                    } if isinstance(config.load_time, TimePeriod) else None,
                                    "fixedTime": config.load_time and {
                                        "loadTime": config.load_time.load_time.isoformat(),
                                        "overrides": config.load_time.load_overrides and [
                                            {
                                                "loadId": key,
                                                "loadWattsOverride": value.load_watts,
                                                "genWattsOverride": value.gen_watts,
                                                "loadVarOverride": value.load_var,
                                                "genVarOverride": value.gen_var,
                                            } for key, value in config.load_time.load_overrides.items()
                                        ]
                                    } if isinstance(config.load_time, FixedTime) else None,
                                } for config in work_package.syf_config.configs
                            ]
                        } if isinstance(work_package.syf_config, FeederConfigs) else None,
                        "forecastConfig": {
                            "feeders": work_package.syf_config.feeders,
                            "years": work_package.syf_config.years,
                            "scenarios": work_package.syf_config.scenarios,
                            "timePeriod": {
                                "startTime": work_package.syf_config.load_time.start_time.isoformat(),
                                "endTime": work_package.syf_config.load_time.end_time.isoformat(),
                                "overrides": work_package.syf_config.load_time.load_overrides and {
                                    key: value.__dict__
                                    for key, value in work_package.syf_config.load_time.load_overrides.items()}
                            } if isinstance(work_package.syf_config.load_time, TimePeriod) else None,
                            "fixedTime": work_package.syf_config.load_time and {
                                "loadTime": work_package.syf_config.load_time.load_time.isoformat(),
                                "overrides": work_package.syf_config.load_time.load_overrides and {
                                    key: value.__dict__
                                    for key, value in work_package.syf_config.load_time.load_overrides.items()}
                            } if isinstance(work_package.syf_config.load_time, FixedTime) else None
                        } if isinstance(work_package.syf_config, ForecastConfig) else None,
                        "qualityAssuranceProcessing": work_package.quality_assurance_processing,
                        "generatorConfig": work_package.generator_config and {
                            "model": work_package.generator_config.model and {
                                "vmPu": work_package.generator_config.model.vm_pu,
                                "loadVMinPu": work_package.generator_config.model.load_vmin_pu,
                                "loadVMaxPu": work_package.generator_config.model.load_vmax_pu,
                                "genVMinPu": work_package.generator_config.model.gen_vmin_pu,
                                "genVMaxPu": work_package.generator_config.model.gen_vmax_pu,
                                "loadModel": work_package.generator_config.model.load_model,
                                "collapseSWER": work_package.generator_config.model.collapse_swer,
                                "calibration": work_package.generator_config.model.calibration,
                                "pFactorBaseExports": work_package.generator_config.model.p_factor_base_exports,
                                "pFactorForecastPv": work_package.generator_config.model.p_factor_forecast_pv,
                                "pFactorBaseImports": work_package.generator_config.model.p_factor_base_imports,
                                "fixSinglePhaseLoads": work_package.generator_config.model.fix_single_phase_loads,
                                "maxSinglePhaseLoad": work_package.generator_config.model.max_single_phase_load,
                                "fixOverloadingConsumers": work_package.generator_config.model.fix_overloading_consumers,
                                "maxLoadTxRatio": work_package.generator_config.model.max_load_tx_ratio,
                                "maxGenTxRatio": work_package.generator_config.model.max_gen_tx_ratio,
                                "fixUndersizedServiceLines": work_package.generator_config.model.fix_undersized_service_lines,
                                "maxLoadServiceLineRatio": work_package.generator_config.model.max_load_service_line_ratio,
                                "maxLoadLvLineRatio": work_package.generator_config.model.max_load_lv_line_ratio,
                                "collapseLvNetworks": work_package.generator_config.model.collapse_lv_networks,
                                "feederScenarioAllocationStrategy": work_package.generator_config.model.feeder_scenario_allocation_strategy and work_package.generator_config.model.feeder_scenario_allocation_strategy.name,
                                "closedLoopVRegEnabled": work_package.generator_config.model.closed_loop_v_reg_enabled,
                                "closedLoopVRegReplaceAll": work_package.generator_config.model.closed_loop_v_reg_replace_all,
                                "closedLoopVRegSetPoint": work_package.generator_config.model.closed_loop_v_reg_set_point,
                                "closedLoopVBand": work_package.generator_config.model.closed_loop_v_band,
                                "closedLoopTimeDelay": work_package.generator_config.model.closed_loop_time_delay,
                                "closedLoopVLimit": work_package.generator_config.model.closed_loop_v_limit,
                                "defaultTapChangerTimeDelay": work_package.generator_config.model.default_tap_changer_time_delay,
                                "defaultTapChangerSetPointPu": work_package.generator_config.model.default_tap_changer_set_point_pu,
                                "defaultTapChangerBand": work_package.generator_config.model.default_tap_changer_band,
                                "splitPhaseDefaultLoadLossPercentage": work_package.generator_config.model.split_phase_default_load_loss_percentage,
                                "splitPhaseLVKV": work_package.generator_config.model.split_phase_lv_kv,
                                "swerVoltageToLineVoltage": work_package.generator_config.model.swer_voltage_to_line_voltage,
                                "loadPlacement": work_package.generator_config.model.load_placement and work_package.generator_config.model.load_placement.name,
                                "loadIntervalLengthHours": work_package.generator_config.model.load_interval_length_hours,
                                "meterPlacementConfig": work_package.generator_config.model.meter_placement_config and {
                                    "feederHead": work_package.generator_config.model.meter_placement_config.feeder_head,
                                    "distTransformers": work_package.generator_config.model.meter_placement_config.dist_transformers,
                                    "switchMeterPlacementConfigs": work_package.generator_config.model.meter_placement_config.switch_meter_placement_configs and [
                                        {
                                            "meterSwitchClass": spc.meter_switch_class and spc.meter_switch_class.name,
                                            "namePattern": spc.name_pattern
                                        } for spc in
                                        work_package.generator_config.model.meter_placement_config.switch_meter_placement_configs
                                    ],
                                    "energyConsumerMeterGroup": work_package.generator_config.model.meter_placement_config.energy_consumer_meter_group
                                },
                                "seed": work_package.generator_config.model.seed,
                                "defaultLoadWatts": work_package.generator_config.model.default_load_watts,
                                "defaultGenWatts": work_package.generator_config.model.default_gen_watts,
                                "defaultLoadVar": work_package.generator_config.model.default_load_var,
                                "defaultGenVar": work_package.generator_config.model.default_gen_var,
                                "transformerTapSettings": work_package.generator_config.model.transformer_tap_settings,
                                "ctPrimScalingFactor": work_package.generator_config.model.ct_prim_scaling_factor,
                            },
                            "solve": work_package.generator_config.solve and {
                                "normVMinPu": work_package.generator_config.solve.norm_vmin_pu,
                                "normVMaxPu": work_package.generator_config.solve.norm_vmax_pu,
                                "emergVMinPu": work_package.generator_config.solve.emerg_vmin_pu,
                                "emergVMaxPu": work_package.generator_config.solve.emerg_vmax_pu,
                                "baseFrequency": work_package.generator_config.solve.base_frequency,
                                "voltageBases": work_package.generator_config.solve.voltage_bases,
                                "maxIter": work_package.generator_config.solve.max_iter,
                                "maxControlIter": work_package.generator_config.solve.max_control_iter,
                                "mode": work_package.generator_config.solve.mode and work_package.generator_config.solve.mode.name,
                                "stepSizeMinutes": work_package.generator_config.solve.step_size_minutes
                            },
                            "rawResults": work_package.generator_config.raw_results and {
                                "energyMeterVoltagesRaw": work_package.generator_config.raw_results.energy_meter_voltages_raw,
                                "energyMetersRaw": work_package.generator_config.raw_results.energy_meters_raw,
                                "resultsPerMeter": work_package.generator_config.raw_results.results_per_meter,
                                "overloadsRaw": work_package.generator_config.raw_results.overloads_raw,
                                "voltageExceptionsRaw": work_package.generator_config.raw_results.voltage_exceptions_raw
                            }
                        },
                        "executorConfig": {},
                        "resultProcessorConfig": work_package.result_processor_config and {
                            "storedResults": work_package.result_processor_config.stored_results and {
                                "energyMeterVoltagesRaw": work_package.result_processor_config.stored_results.energy_meter_voltages_raw,
                                "energyMetersRaw": work_package.result_processor_config.stored_results.energy_meters_raw,
                                "overloadsRaw": work_package.result_processor_config.stored_results.overloads_raw,
                                "voltageExceptionsRaw": work_package.result_processor_config.stored_results.voltage_exceptions_raw,
                            },
                            "metrics": work_package.result_processor_config.metrics and {
                                "calculatePerformanceMetrics": work_package.result_processor_config.metrics.calculate_performance_metrics
                            },
                            "writerConfig": work_package.result_processor_config.writer_config and {
                                "writerType": work_package.result_processor_config.writer_config.writer_type and work_package.result_processor_config.writer_config.writer_type.name,
                                "outputWriterConfig": work_package.result_processor_config.writer_config.output_writer_config and {
                                    "enhancedMetricsConfig": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config and {
                                        "populateEnhancedMetrics": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_enhanced_metrics,
                                        "populateEnhancedMetricsProfile": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_enhanced_metrics_profile,
                                        "populateDurationCurves": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_duration_curves,
                                        "populateConstraints": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_constraints,
                                        "populateWeeklyReports": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.populate_weekly_reports,
                                        "calculateNormalForLoadThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_normal_for_load_thermal,
                                        "calculateEmergForLoadThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_emerg_for_load_thermal,
                                        "calculateNormalForGenThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_normal_for_gen_thermal,
                                        "calculateEmergForGenThermal": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_emerg_for_gen_thermal,
                                        "calculateCO2": work_package.result_processor_config.writer_config.output_writer_config.enhanced_metrics_config.calculate_co2
                                    }
                                }
                            }
                        },
                        "intervention": work_package.intervention and {
                            "baseWorkPackageId": work_package.intervention.base_work_package_id,
                            "yearRange": {
                                "maxYear": work_package.intervention.year_range.max_year,
                                "minYear": work_package.intervention.year_range.min_year
                            },
                            "allocationLimitPerYear": work_package.intervention.allocation_limit_per_year,
                            "interventionType": work_package.intervention.intervention_type.name,
                            "candidateGeneration": work_package.intervention.candidate_generation and {
                                "type": work_package.intervention.candidate_generation.type.name,
                                "interventionCriteriaName": work_package.intervention.candidate_generation.intervention_criteria_name,
                                "voltageDeltaAvgThreshold": work_package.intervention.candidate_generation.voltage_delta_avg_threshold,
                                "voltageUnderLimitHoursThreshold": work_package.intervention.candidate_generation.voltage_under_limit_hours_threshold,
                                "voltageOverLimitHoursThreshold": work_package.intervention.candidate_generation.voltage_over_limit_hours_threshold,
                                "tapWeightingFactorLowerThreshold": work_package.intervention.candidate_generation.tap_weighting_factor_lower_threshold,
                                "tapWeightingFactorUpperThreshold": work_package.intervention.candidate_generation.tap_weighting_factor_upper_threshold,
                            },
                            "allocationCriteria": work_package.intervention.allocation_criteria,
                            "specificAllocationInstance": work_package.intervention.specific_allocation_instance,
                            "phaseRebalanceProportions": work_package.intervention.phase_rebalance_proportions and {
                                "a": work_package.intervention.phase_rebalance_proportions.a,
                                "b": work_package.intervention.phase_rebalance_proportions.b,
                                "c": work_package.intervention.phase_rebalance_proportions.c
                            },
                            "dvms": work_package.intervention.dvms and {
                                "lowerLimit": work_package.intervention.dvms.lower_limit,
                                "upperLimit": work_package.intervention.dvms.upper_limit,
                                "lowerPercentile": work_package.intervention.dvms.lower_percentile,
                                "upperPercentile": work_package.intervention.dvms.upper_percentile,
                                "maxIterations": work_package.intervention.dvms.max_iterations,
                                "regulatorConfig": {
                                    "puTarget": work_package.intervention.dvms.regulator_config.pu_target,
                                    "puDeadbandPercent": work_package.intervention.dvms.regulator_config.pu_deadband_percent,
                                    "maxTapChangePerStep": work_package.intervention.dvms.regulator_config.max_tap_change_per_step,
                                    "allowPushToLimit": work_package.intervention.dvms.regulator_config.allow_push_to_limit
                                }
                            }
                        }
                    }
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def cancel_hosting_capacity_work_package(self, work_package_id: str):
        """
        Send request to hosting capacity service to cancel a running work package

        :param work_package_id: The id of the running work package to cancel
        :return: The HTTP response received from the Evolve App Server after attempting to cancel work package
        """
        return get_event_loop().run_until_complete(self.async_cancel_hosting_capacity_work_package(work_package_id))

    async def async_cancel_hosting_capacity_work_package(self, work_package_id: str):
        """
        Send asynchronous request to hosting capacity service to cancel a running work package

        :param work_package_id: The id of the running work package to cancel
        :return: The HTTP response received from the Evolve App Server after attempting to cancel work package
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    mutation cancelWorkPackage($workPackageId: ID!) {
                        cancelWorkPackage(workPackageId: $workPackageId)
                    }
                """,
                "variables": {"workPackageId": work_package_id}
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def get_hosting_capacity_work_packages_progress(self):
        """
        Retrieve running work packages progress information from hosting capacity service

        :return: The HTTP response received from the Evolve App Server after requesting work packages progress info
        """
        return get_event_loop().run_until_complete(self.async_get_hosting_capacity_work_packages_progress())

    async def async_get_hosting_capacity_work_packages_progress(self):
        """
        Asynchronously retrieve running work packages progress information from hosting capacity service

        :return: The HTTP response received from the Evolve App Server after requesting work packages progress info
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    query getWorkPackageProgress {
                        getWorkPackageProgress {
                            pending
                            inProgress {
                               id
                               progressPercent
                               pending
                               generation
                               execution
                               resultProcessing
                               failureProcessing
                               complete
                            }
                        }
                    }
                """,
                "variables": {}
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def run_feeder_load_analysis_report(self, feeder_load_analysis_input: FeederLoadAnalysisInput):
        """
        Send request to evolve app server to run a feeder load analysis study

        :param feeder_load_analysis_input:: An instance of the `FeederLoadAnalysisConfig` data class representing the configuration for the run
        :return: The HTTP response received from the Evolve App Server after attempting to run work package
        """
        return get_event_loop().run_until_complete(
            self.async_run_feeder_load_analysis_report(feeder_load_analysis_input))

    async def async_run_feeder_load_analysis_report(self, feeder_load_analysis_input: FeederLoadAnalysisInput):
        """
        Asynchronously send request to evolve app server to run a feeder load analysis study

        :return: The HTTP response received from the Evolve App Server after requesting a feeder load analysis report
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query":
                    """
                    mutation runFeederLoadAnalysis($input: FeederLoadAnalysisInput!) {
                        runFeederLoadAnalysis(input: $input)
                    }
                """,
                "variables": {
                    "input": {
                        "feeders": feeder_load_analysis_input.feeders,
                        "substations": feeder_load_analysis_input.substations,
                        "subGeographicalRegions": feeder_load_analysis_input.sub_geographical_regions,
                        "geographicalRegions": feeder_load_analysis_input.feeders,
                        "startDate": feeder_load_analysis_input.start_date,
                        "endDate": feeder_load_analysis_input.end_date,
                        "fetchLvNetwork": feeder_load_analysis_input.fetch_lv_network,
                        "processFeederLoads": feeder_load_analysis_input.process_feeder_loads,
                        "processCoincidentLoads": feeder_load_analysis_input.process_coincident_loads,
                        "produceConductorReport": True, # We currently only support conductor report
                        "aggregateAtFeederLevel": feeder_load_analysis_input.aggregate_at_feeder_level,
                        "output": feeder_load_analysis_input.output
                    }
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def upload_study(self, study: Study):
        """
        Uploads a new study to the Evolve App Server
        :param study: An instance of a data class representing a new study
        """
        return get_event_loop().run_until_complete(self.async_upload_study(study))

    async def async_upload_study(self, study: Study):
        """
        Uploads a new study to the Evolve App Server
        :param study: An instance of a data class representing a new study
        :return: The HTTP response received from the Evolve App Server after attempting to upload the study
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    mutation uploadStudy($study: StudyInput!) {
                        addStudies(studies: [$study])
                    }
                """,
                "variables": {
                    "study": {
                        "name": study.name,
                        "description": study.description,
                        "tags": study.tags,
                        "styles": study.styles,
                        "results": [{
                            "name": result.name,
                            "geoJsonOverlay": result.geo_json_overlay and {
                                "data": result.geo_json_overlay.data,
                                "sourceProperties": result.geo_json_overlay.source_properties,
                                "styles": result.geo_json_overlay.styles
                            },
                            "stateOverlay": result.state_overlay and {
                                "data": result.state_overlay.data,
                                "styles": result.state_overlay.styles
                            },
                            "sections": [{
                                "type": section.type,
                                "name": section.name,
                                "description": section.description,
                                "columns": section.columns,
                                "data": section.data
                            } for section in result.sections]
                        } for result in study.results]
                    }
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def run_hosting_capacity_calibration(self, calibration_name: str, local_calibration_time: Optional[str] = None, feeders: Optional[List[str]] = None):
        """
        Send request to run hosting capacity calibration
        :param calibration_name: A string representation of the calibration name
        :param local_calibration_time: A string representation of the calibration time, in model time.
        :param feeders: A list of feeder ID's to run the calibration over. If not supplied then the calibration is run over all feeders in the network.
        :return: The HTTP response received from the Evolve App Server after attempting to run the calibration
        """
        return get_event_loop().run_until_complete(
            self.async_run_hosting_capacity_calibration(calibration_name, local_calibration_time, feeders))

    async def async_run_hosting_capacity_calibration(self, calibration_name: str,
                                                     calibration_time_local: Optional[str] = None, feeders: Optional[List[str]] = None):
        """
        Send asynchronous request to run hosting capacity calibration
        :param calibration_name: A string representation of the calibration name
        :param calibration_time_local: A string representation of the calibration time, in model time.
        :param feeders: A list of feeder ID's to run the calibration over. If not supplied then the calibration is run over all feeders in the network.
        :return: The HTTP response received from the Evolve App Server after attempting to run the calibration
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    mutation runCalibration($calibrationName: String!, $calibrationTimeLocal: LocalDateTime, $feeders: [String!]) {
                        runCalibration(calibrationName: $calibrationName, calibrationTimeLocal: $calibrationTimeLocal, feeders: $feeders)
                    }
                """,
                "variables": {
                    "calibrationName": calibration_name,
                    "calibrationTimeLocal": calibration_time_local,
                    "feeders": feeders
                }
            }

            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def get_hosting_capacity_calibration_run(self, id: str):
        """
        Retrieve information of a hosting capacity calibration run
        :param id: The calibration ID
        :return: The HTTP response received from the Evolve App Server after requesting calibration run info
        """
        return get_event_loop().run_until_complete(self.async_get_hosting_capacity_calibration_run(id))

    async def async_get_hosting_capacity_calibration_run(self, id: str):
        """
        Retrieve information of a hosting capacity calibration run
        :param id: The calibration ID
        :return: The HTTP response received from the Evolve App Server after requesting calibration run info
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    query getCalibrationRun($id: ID!) {
                        getCalibrationRun(id: $id) {
                            id
                            name
                            workflowId
                            runId
                            calibrationTimeLocal
                            startAt
                            completedAt
                            status
                            feeders
                            calibrationWorkPackageConfig
                        }
                    }
                """,
                "variables": {
                    "id": id
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def get_hosting_capacity_calibration_sets(self):
        """
        Retrieve a list of all completed calibration runs initiated through Evolve App Server
        :return: The HTTP response received from the Evolve App Server after requesting completed calibration runs
        """
        return get_event_loop().run_until_complete(self.async_get_hosting_capacity_calibration_sets())

    async def async_get_hosting_capacity_calibration_sets(self):
        """
        Retrieve a list of all completed calibration runs initiated through Evolve App Server
        :return: The HTTP response received from the Evolve App Server after requesting completed calibration runs
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    query { 
                    getCalibrationSets
                     }
                """
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def run_opendss_export(self, config: OpenDssConfig):
        """
        Send request to run an opendss export
        :param config: The OpenDssConfig for running the export
        :return: The HTTP response received from the Evolve App Server after attempting to run the opendss export
        """
        return get_event_loop().run_until_complete(self.async_run_opendss_export(config))

    async def async_run_opendss_export(self, config: OpenDssConfig):
        """
        Send asynchronous request to run an opendss export
        :param config: The OpenDssConfig for running the export
        :return: The HTTP response received from the Evolve App Server after attempting to run the opendss export
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    mutation createOpenDssModel($input: OpenDssModelInput!) {
                        createOpenDssModel(input: $input)
                    }
                """,
                "variables": {
                    "input": {
                        "modelName": config.model_name,
                        "isPublic": config.is_public,
                        "generationSpec": {
                            "modelOptions": {
                                "feeder": config.feeder,
                                "scenario": config.scenario,
                                "year": config.year
                            },
                            "modulesConfiguration": {
                                "common": {
                                    **({"fixedTime": {"loadTime": config.load_time.load_time.isoformat(),
                                          "overrides": config.load_time.load_overrides and [
                                               {
                                                   "loadId": key,
                                                   "loadWattsOverride": value.load_watts,
                                                   "genWattsOverride": value.gen_watts,
                                                   "loadVarOverride": value.load_var,
                                                   "genVarOverride": value.gen_var,
                                               } for key, value in config.load_time.load_overrides.items()
                                           ]
                                       }} if isinstance(config.load_time, FixedTime) else {}),
                                    **({"timePeriod": {
                                        "startTime": config.load_time.start_time.isoformat(),
                                        "endTime": config.load_time.end_time.isoformat(),
                                        "overrides": config.load_time.load_overrides and [
                                            {
                                                "loadId": key,
                                                "loadWattsOverride": value.load_watts,
                                                "genWattsOverride": value.gen_watts,
                                                "loadVarOverride": value.load_var,
                                                "genVarOverride": value.gen_var,
                                            } for key, value in config.load_time.load_overrides.items()
                                        ]
                                    }} if isinstance(config.load_time, TimePeriod) else {})
                                },
                                **({"generator": {
                                    **({"model": {
                                        "vmPu": config.generator_config.model.vm_pu,
                                        "loadVMinPu": config.generator_config.model.load_vmin_pu,
                                        "loadVMaxPu": config.generator_config.model.load_vmax_pu,
                                        "genVMinPu": config.generator_config.model.gen_vmin_pu,
                                        "genVMaxPu": config.generator_config.model.gen_vmax_pu,
                                        "loadModel": config.generator_config.model.load_model,
                                        "collapseSWER": config.generator_config.model.collapse_swer,
                                        "calibration": config.generator_config.model.calibration,
                                        "pFactorBaseExports": config.generator_config.model.p_factor_base_exports,
                                        "pFactorForecastPv": config.generator_config.model.p_factor_forecast_pv,
                                        "pFactorBaseImports": config.generator_config.model.p_factor_base_imports,
                                        "fixSinglePhaseLoads": config.generator_config.model.fix_single_phase_loads,
                                        "maxSinglePhaseLoad": config.generator_config.model.max_single_phase_load,
                                        "fixOverloadingConsumers": config.generator_config.model.fix_overloading_consumers,
                                        "maxLoadTxRatio": config.generator_config.model.max_load_tx_ratio,
                                        "maxGenTxRatio": config.generator_config.model.max_gen_tx_ratio,
                                        "fixUndersizedServiceLines": config.generator_config.model.fix_undersized_service_lines,
                                        "maxLoadServiceLineRatio": config.generator_config.model.max_load_service_line_ratio,
                                        "maxLoadLvLineRatio": config.generator_config.model.max_load_lv_line_ratio,
                                        "collapseLvNetworks": config.generator_config.model.collapse_lv_networks,
                                        "feederScenarioAllocationStrategy": config.generator_config.model.feeder_scenario_allocation_strategy and config.generator_config.model.feeder_scenario_allocation_strategy.name,
                                        "closedLoopVRegEnabled": config.generator_config.model.closed_loop_v_reg_enabled,
                                        "closedLoopVRegReplaceAll": config.generator_config.model.closed_loop_v_reg_replace_all,
                                        "closedLoopVRegSetPoint": config.generator_config.model.closed_loop_v_reg_set_point,
                                        "closedLoopVBand": config.generator_config.model.closed_loop_v_band,
                                        "closedLoopTimeDelay": config.generator_config.model.closed_loop_time_delay,
                                        "closedLoopVLimit": config.generator_config.model.closed_loop_v_limit,
                                        "defaultTapChangerTimeDelay": config.generator_config.model.default_tap_changer_time_delay,
                                        "defaultTapChangerSetPointPu": config.generator_config.model.default_tap_changer_set_point_pu,
                                        "defaultTapChangerBand": config.generator_config.model.default_tap_changer_band,
                                        "splitPhaseDefaultLoadLossPercentage": config.generator_config.model.split_phase_default_load_loss_percentage,
                                        "splitPhaseLVKV": config.generator_config.model.split_phase_lv_kv,
                                        "swerVoltageToLineVoltage": config.generator_config.model.swer_voltage_to_line_voltage,
                                        "loadPlacement": config.generator_config.model.load_placement and config.generator_config.model.load_placement.name,
                                        "loadIntervalLengthHours": config.generator_config.model.load_interval_length_hours,
                                        "meterPlacementConfig": config.generator_config.model.meter_placement_config and {
                                            "feederHead": config.generator_config.model.meter_placement_config.feeder_head,
                                            "distTransformers": config.generator_config.model.meter_placement_config.dist_transformers,
                                            "switchMeterPlacementConfigs": config.generator_config.model.meter_placement_config.switch_meter_placement_configs and [
                                                {
                                                    "meterSwitchClass": spc.meter_switch_class and spc.meter_switch_class.name,
                                                    "namePattern": spc.name_pattern
                                                } for spc in
                                                config.generator_config.model.meter_placement_config.switch_meter_placement_configs
                                            ],
                                            "energyConsumerMeterGroup": config.generator_config.model.meter_placement_config.energy_consumer_meter_group
                                        },
                                        "seed": config.generator_config.model.seed,
                                        "defaultLoadWatts": config.generator_config.model.default_load_watts,
                                        "defaultGenWatts": config.generator_config.model.default_gen_watts,
                                        "defaultLoadVar": config.generator_config.model.default_load_var,
                                        "defaultGenVar": config.generator_config.model.default_gen_var,
                                        "transformerTapSettings": config.generator_config.model.transformer_tap_settings,
                                        "ctPrimScalingFactor": config.generator_config.model.ct_prim_scaling_factor,
                                    }} if config.generator_config.model else {}),
                                    **({"solve": {
                                        "normVMinPu": config.generator_config.solve.norm_vmin_pu,
                                        "normVMaxPu": config.generator_config.solve.norm_vmax_pu,
                                        "emergVMinPu": config.generator_config.solve.emerg_vmin_pu,
                                        "emergVMaxPu": config.generator_config.solve.emerg_vmax_pu,
                                        "baseFrequency": config.generator_config.solve.base_frequency,
                                        "voltageBases": config.generator_config.solve.voltage_bases,
                                        "maxIter": config.generator_config.solve.max_iter,
                                        "maxControlIter": config.generator_config.solve.max_control_iter,
                                        "mode": config.generator_config.solve.mode and config.generator_config.solve.mode.name,
                                        "stepSizeMinutes": config.generator_config.solve.step_size_minutes
                                    }} if config.generator_config.solve else {}),
                                    **({"rawResults": {
                                        "energyMeterVoltagesRaw": config.generator_config.raw_results.energy_meter_voltages_raw,
                                        "energyMetersRaw": config.generator_config.raw_results.energy_meters_raw,
                                        "resultsPerMeter": config.generator_config.raw_results.results_per_meter,
                                        "overloadsRaw": config.generator_config.raw_results.overloads_raw,
                                        "voltageExceptionsRaw": config.generator_config.raw_results.voltage_exceptions_raw
                                    }} if config.generator_config.raw_results else {})
                                }} if config.generator_config else {})
                            }
                        }
                    }
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def get_paged_opendss_models(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        query_filter: Optional[GetOpenDssModelsFilterInput] = None,
        query_sort: Optional[GetOpenDssModelsSortCriteriaInput] = None):
        """
        Retrieve a paginated opendss export run information
        :param limit: The number of opendss export runs to retrieve
        :param offset: The number of opendss export runs to skip
        :param query_filter: The filter to apply to the query
        :param query_sort: The sorting to apply to the query
        :return: The HTTP response received from the Evolve App Server after requesting opendss export run information
        """
        return get_event_loop().run_until_complete(
            self.async_get_paged_opendss_models(limit, offset, query_filter, query_sort))

    async def async_get_paged_opendss_models(
        self,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        query_filter: Optional[GetOpenDssModelsFilterInput] = None,
        query_sort: Optional[GetOpenDssModelsSortCriteriaInput] = None):
        """
        Retrieve a paginated opendss export run information
        :param limit: The number of opendss export runs to retrieve
        :param offset: The number of opendss export runs to skip
        :param query_filter: The filter to apply to the query
        :param query_sort: The sorting to apply to the query
        :return: The HTTP response received from the Evolve App Server after requesting opendss export run information
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)
            json = {
                "query": """
                    query pagedOpenDssModels($limit: Int, $offset: Long, $filter: GetOpenDssModelsFilterInput, $sort: GetOpenDssModelsSortCriteriaInput) {
                    pagedOpenDssModels(limit: $limit, offset: $offset, filter: $filter,sort: $sort) {
                        totalCount
                        offset,
                        models {
                            id
                            name
                            createdAt
                            createdBy
                            state
                            downloadUrl
                            isPublic
                            errors
                            generationSpec {
                                modelOptions{
                                    scenario
                                    year
                                    feeder
                                }
                                modulesConfiguration {
                                    common {
                                        fixedTime{
                                            loadTime
                                            overrides {
                                                loadId
                                                loadWattsOverride
                                                genWattsOverride
                                                loadVarOverride
                                                genVarOverride
                                            }
                                        }
                                        timePeriod {
                                            startTime
                                            endTime
                                            overrides {
                                                loadId
                                                loadWattsOverride
                                                genWattsOverride
                                                loadVarOverride
                                                genVarOverride
                                            }
                                        }
                                    }
                                    generator {
                                        model {
                                            vmPu
                                            loadVMinPu
                                            loadVMaxPu
                                            genVMinPu
                                            genVMaxPu
                                            loadModel
                                            collapseSWER
                                            calibration
                                            pFactorBaseExports
                                            pFactorForecastPv
                                            pFactorBaseImports
                                            fixSinglePhaseLoads
                                            maxSinglePhaseLoad
                                            fixOverloadingConsumers
                                            maxLoadTxRatio
                                            maxGenTxRatio
                                            fixUndersizedServiceLines
                                            maxLoadServiceLineRatio
                                            maxLoadLvLineRatio
                                            collapseLvNetworks
                                            feederScenarioAllocationStrategy
                                            closedLoopVRegEnabled
                                            closedLoopVRegReplaceAll
                                            closedLoopVRegSetPoint
                                            closedLoopVBand
                                            closedLoopTimeDelay
                                            closedLoopVLimit
                                            defaultTapChangerTimeDelay
                                            defaultTapChangerSetPointPu
                                            defaultTapChangerBand
                                            splitPhaseDefaultLoadLossPercentage
                                            splitPhaseLVKV
                                            swerVoltageToLineVoltage
                                            loadPlacement
                                            loadIntervalLengthHours
                                            meterPlacementConfig {
                                                feederHead
                                                distTransformers
                                                switchMeterPlacementConfigs {
                                                  meterSwitchClass
                                                  namePattern
                                                }
                                                energyConsumerMeterGroup
                                            }
                                            seed
                                            defaultLoadWatts
                                            defaultGenWatts
                                            defaultLoadVar
                                            defaultGenVar
                                            transformerTapSettings
                                            ctPrimScalingFactor
                                        }
                                        solve {
                                            normVMinPu
                                            normVMaxPu
                                            emergVMinPu
                                            emergVMaxPu
                                            baseFrequency
                                            voltageBases
                                            maxIter
                                            maxControlIter
                                            mode
                                            stepSizeMinutes
                                        }
                                        rawResults {
                                            energyMeterVoltagesRaw
                                            energyMetersRaw
                                            resultsPerMeter
                                            overloadsRaw
                                            voltageExceptionsRaw
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                """,
                "variables": {
                    **({"limit": limit} if limit is not None else {}),
                    **({"offset": offset} if offset is not None else {}),
                    **({"filter": {
                        "name": query_filter.name,
                        "isPublic": query_filter.is_public,
                        "state": query_filter.state and [state.name for state in query_filter.state]
                    }} if query_filter else {}),
                    **({"sort": {
                        "name": query_sort.name and query_sort.name.name,
                        "createdAt": query_sort.created_at and query_sort.created_at.name,
                        "state": query_sort.state and query_sort.state.name,
                        "isPublic": query_sort.is_public and query_sort.is_public.name
                    }} if query_sort else {})
                }
            }
            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.post(
                construct_url(protocol=self._protocol, host=self._host, port=self._port, path="/api/graphql"),
                headers=self._get_request_headers(),
                json=json,
                ssl=sslcontext if self._verify_certificate else False
            ) as response:
                if response.ok:
                    response = await response.json()
                else:
                    response = await response.text()
                return response

    def get_opendss_model_download_url(self, run_id: int):
        """
        Retrieve a download url for the specified opendss export run id
        :param run_id: The opendss export run ID
        :return: The HTTP response received from the Evolve App Server after requesting opendss export model download url
        """
        return get_event_loop().run_until_complete(self.async_get_opendss_model_download_url(run_id))

    async def async_get_opendss_model_download_url(self, run_id: int):
        """
        Retrieve a download url for the specified opendss export run id
        :param run_id: The opendss export run ID
        :return: The HTTP response received from the Evolve App Server after requesting opendss export model download url
        """
        with warnings.catch_warnings():
            if not self._verify_certificate:
                warnings.filterwarnings("ignore", category=InsecureRequestWarning)

            if self._verify_certificate:
                sslcontext = ssl.create_default_context(cafile=self._ca_filename)

            async with self.session.get(
                construct_url(protocol=self._protocol, host=self._host, port=self._port,
                              path=f"/api/opendss-model/{run_id}"),
                headers=self._get_request_headers(),
                ssl=sslcontext if self._verify_certificate else False,
                allow_redirects=False
            ) as response:
                if response.status == HTTPStatus.FOUND:
                    response = response.headers["Location"]
                else:
                    response = await response.text()
                return response

    def get_opendss_model(self, model_id: int):
        """
        Retrieve information of a OpenDss model export
        :param model_id: The OpenDss model export ID
        :return: The HTTP response received from the Evolve App Server after requesting the openDss model info
        """
        return get_event_loop().run_until_complete(self.async_get_opendss_model(model_id))

    async def async_get_opendss_model(self, model_id: int):
        """
        Retrieve information of a OpenDss model export
        :param model_id: The OpenDss model export ID
        :return: The HTTP response received from the Evolve App Server after requesting the openDss model info
        """

        offset = 0
        page_size = 20

        while True:
            response = await self.async_get_paged_opendss_models(page_size, offset)
            total_count = int(response["data"]["pagedOpenDssModels"]["totalCount"])
            page_count = len(response["data"]["pagedOpenDssModels"]["models"])
            for model in response["data"]["pagedOpenDssModels"]["models"]:
                if model["id"] == model_id:
                    return model
            offset += page_count

            if offset >= total_count:
                break

        raise ValueError(f"Model id:{model_id} was not found in EAS database.")
